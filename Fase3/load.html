<!-- Adapted from https://bl.ocks.org/chrisbrasington and https://gist.github.com/kylemcdonald/9593057 -->
<!-- Transformations matrix adapted from https://gist.github.com/jeanlescure/e27c93b73a10b64e85e4 -->
<!-- Phong by https://github.com/sneha-belkhale/threejs-shader-demo/blob/master/public/html/index_filled.html -->
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>OBJloader</title>
		<meta charset="utf-8">
        
        <!-- Botões usados na escala do objeto Death Star-->
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!--
        <button id= "ScaleM">Scale + <br>Death Star </button>
        <button id= "ScaleL">Scale - <br>Death Star </button>
-->
        <!-- Input Range usado na escala do objeto Vader-->
     <!--BOTÃO RANGE PAROU DE FUNCIONAR KKKKKKK -->
<!--     <input id="range" type="range" min="-200" max="230" value="0">-->
        
		<style>
			body {
				font-family: Monospace;
				background-color: #fff;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
    
      /*Definição dos estilos dos botões */			
   /* #range{
        position: absolute;
        bottom: 100px;
        left: 520px;
        font-size: 12px;
        width: 100px;
    }
*/
    #footer { 
        width:100%;
        position: absolute;
        text-align: center;
        bottom: 1%; 
    }
        
		</style>
	</head>

	<body id = "corpo">
<div id="info">
            OBJ loader with ThreeJS
		</div>
        
<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r61/three.min.js"></script>    
<script src="../three/three.js"></script>
<script src="../three/OBJ_loader.js"></script>
<script src="../three/MTLLoader.js"></script>
<script src="../three/DDSLoader.js"></script>
        <!-- Descreve vertex shader para Death Star -->    
        <script id="vertexShaderDS" type="x-shader/x-vertex">
            varying vec3 vNormal;
             varying vec3 vViewPosition;
            uniform float timeDelta;
            //Escalares usados nas matrizes de tranformação
            float translationX = 310.0;
            float translationY = 300.0;
            float translationZ = -150.0;
            float scaleX = 0.3;
            float scaleY = 0.3;
            float scaleZ = 0.3;
            
            //variavel para matriz de tranformação
            varying mat4 mTransformation;
            
            void main()	{
                
                // Translação
                mat4 tPos = mat4(   vec4(1.0, 0.0, 0.0, 0.0),
                                    vec4(0.0, 1.0, 0.0, 0.0),
                                    vec4(0.0, 0.0, 1.0, 0.0),
                                    vec4(translationX, translationY, translationZ, 1.0));

                //Escala
                mat4 sPos = mat4(   vec4(scaleX, 0.0, 0.0, 0.0),
                                    vec4(0.0, scaleY, 0.0, 0.0),
                                    vec4(0.0, 0.0, scaleZ, 0.0),
                                    vec4(0.0, 0.0, 0.0, 1.0));
                                    
                //Matriz final de tranformação
                mTransformation =  tPos * sPos;
                 
                //Para Phong 
                vec3 center = vec3(0.0, 0.0, 0.0);
                vec3 p = position;
                float distance = length(center - p);
                p += sin(distance + timeDelta/1000.0)*0.5;
                vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
                vViewPosition = -modelViewPosition.xyz;
                vNormal = normalMatrix * normal;
                
                //Aplicação da matriz de tranformação e posicionamento do objeto
                gl_Position = projectionMatrix * viewMatrix * mTransformation * vec4( position, 1.0 ); 
	        }
            
        </script>
        
          <script id="vertexShaderDV" type="x-shader/x-vertex">
            
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            uniform float timeDelta;
            
            //Escalares usados nas matrizes de tranformação
            float translationX = 150.0;
            float translationY = 90.0;
            float translationZ = 0.0;
            float scaleX = 25.0;
            float scaleY = 25.0;
            float scaleZ = 25.0;
            float rotationY = 0.75;
        
            //variavel para armazenar matriz final de transformação
            varying mat4 mTransformation;
            
            void main()	{
                
                // Translação
                mat4 tPos = mat4(   vec4(1.0, 0.0, 0.0, 0.0),
                                    vec4(0.0, 1.0, 0.0, 0.0),
                                    vec4(0.0, 0.0, 1.0, 0.0),
                                    vec4(translationX, translationY, translationZ, 1.0));

                //Rotação
              
                mat4 rYPos = mat4(  vec4(cos(rotationY), 0.0, sin(rotationY), 0.0),
                                    vec4(0.0, 1.0, 0.0, 0.0),
                                    vec4(-sin(rotationY), 0.0, cos(rotationY), 0.0),
                                    vec4(0.0, 0.0, 0.0, 1.0));
           
                //Escala
                mat4 sPos = mat4(   vec4(scaleX, 0.0, 0.0, 0.0),
                                    vec4(0.0, scaleY, 0.0, 0.0),
                                    vec4(0.0, 0.0, scaleZ, 0.0),
                                    vec4(0.0, 0.0, 0.0, 1.0));
                
                //matriz final de tranformação
                
                mTransformation =  tPos * rYPos * sPos;
                
                //para Phong
                vec3 center = vec3(0.0, 0.0, 0.0);
                vec3 p = position;
                float distance = length(center - p);
                p += sin(distance + timeDelta/1000.0)*0.5;
                vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
                vViewPosition = -modelViewPosition.xyz;
                vNormal = normalMatrix * normal;
                
                //Aplicação da matriz de tranformação e posicionamento do objeto
                gl_Position = projectionMatrix * modelViewMatrix * mTransformation * vec4( position, 1.0 );
	        }
        </script>
        
       
        
		<script>
        var clock = new THREE.Clock();
        var delta = clock.getDelta(); // seconds.
        var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second
			     var container, stats;
			     var camera, scene, renderer; //necessário para vizualização
			     var mouseX = 0, mouseY = 0; //inicializa a posição do mouse
			     var windowHalfX = window.innerWidth / 2;
			     var windowHalfY = window.innerHeight / 2;
            
init();
animate();
function init() {
 
				container = document.createElement( 'div' );
				document.body.appendChild( container );
    
    //Cria camera
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set(0, 200, 600);
				
    //Cria cenário
				scene = new THREE.Scene();
    

    //aplica iluminação do cenário e para visualização da cena
    var ambient = new THREE.AmbientLight( 0x10105a );
				scene.add( ambient );
         
    var light = new THREE.PointLight( 0xa5ccff, 1 );
    light.position.set(300,300,150);
    scene.add( light );
       
    var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set(-200, 300, 0 );
				scene.add( directionalLight );

                
    var uniforms = ({
        timeDelta : {type: 'f', value: 0},
        emissive : {type: 'c', value: new THREE.Color(0x5e807f)},
        specular : {type: 'c', value: new THREE.Color(0xe09278)}
    });


    var phongShader = THREE.ShaderLib.phong;
    var mUniforms = THREE.UniformsUtils.merge([phongShader.uniforms, uniforms]);

    //Aplicação dos shaders para Death Star
    var material_deathstar = new THREE.ShaderMaterial( {
        uniforms: mUniforms,
        vertexShader: document.getElementById( 'vertexShaderDS' ).textContent,
        fragmentShader: phongShader.fragmentShader,
        lights: true,
        side : THREE.DoubleSide
    });

    var loader = new THREE.OBJLoader();
    loader.load( '../OBJ/DeathStar/deathstar-.obj', function ( object ) {
        object.traverse( function ( child ) {    
        if ( child instanceof THREE.Mesh )
            child.material = material_deathstar;

        });
        death_star = object;

        scene.add( death_star ); //coloca o objeto na cena
    } );



    //Aplicação dos shaders para Death Star
    var material_darth = new THREE.ShaderMaterial( {
        uniforms: mUniforms,
        vertexShader: document.getElementById( 'vertexShaderDV' ).textContent,
        fragmentShader: phongShader.fragmentShader,
        lights: true,
        side : THREE.DoubleSide
    });   

    var loader = new THREE.OBJLoader();
    loader.load( '../OBJ/vader.obj', function ( object ) {
        object.traverse( function ( child ) {    
        if ( child instanceof THREE.Mesh )
            child.material = material_darth;
        });
        darth_vader = object
        scene.add( darth_vader );
    });

    THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader());
    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.setPath( '../OBJ/Falcon/' );  
    mtlLoader.load( 'falcon.mtl', function( materials ) {
        materials.preload();   
        var loader = new THREE.OBJLoader();
        loader.setMaterials( materials );
        loader.setPath( '../OBJ/Falcon/' );      
        loader.load( 'falcon.obj', function ( object ) {
            object.position.set(-450, 350, -300);
            object.scale.set(0.015, 0.015, 0.015);
            object.rotation.x = 0.9;
            object.rotation.y = 1;
            falcon = object;
            scene.add( falcon );
        });
    });

   
    THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader());
    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.setPath( '../OBJ/RDD2/' );  
    mtlLoader.load( 'r2-d2.mtl', function( materials ) {
        materials.preload();
        var loader = new THREE.OBJLoader();
        loader.setMaterials( materials );
        loader.setPath( '../OBJ/RDD2/' );  
        loader.load( 'r2-d2.obj', function ( object ) {
            object.position.set(-200, 50, 0);
            object.scale.set(0.5, 0.5, 0.5);
            object.rotation.y = 0.3;
            r2d2 = object;
            scene.add( r2d2 );

        });
    });

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
     
}
                        
//Adapta cenário e vizualização de acordo com o tamanho da janela
function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
}    
            
function animate() {
    requestAnimationFrame( animate );   
    render();
}
			
function render() {
                
    /* Rotação para Escala Estrela da Morte usando função pronta do three.js */
    death_star.rotation.y += 0.02;

   /* document.getElementById( "range" ).onchange = function () {
        darth_vader.scale.x = 55;
        darth_vader.scale.y = 55;
        darth_vader.scale.z = 55;
        darth_vader.scale.x += document.getElementById( "range" ).value/10;
        darth_vader.scale.y += document.getElementById( "range" ).value/10;
        darth_vader.scale.z += document.getElementById( "range" ).value/10;

    };*/

    document.getElementById("corpo").onkeypress = function (e) {
         var keyCode = e.keyCode;
            if(keyCode == 32) {
                if (camera.position.x == 0)
                    camera.position.set(-100, 300, 500);
                else if (camera.position.x == -100)
                    camera.position.set(100, 200, 550);
                else
                    camera.position.set(0, 200, 600);
            }
    }



    //renderização final da câmera
    renderer.render( scene, camera );
                
}

</script>

<div id="footer">Aperte "barra de espaço" para mudar a posição da câmera</div>
	   </body>
</html>
